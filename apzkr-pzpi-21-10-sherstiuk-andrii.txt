Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для контролю тренувань гірськолижників


		Студент гр. ПЗПІ-21-10	_________________ Шерстюк А. Р.
							(підпис)
		Керівник роботи			_________________ доц. Лещинська І.О.
							(підпис)
							      Роботу захищено «__» ______ 2024.р
							      з оцінкою _______________________
		Комісія:				_______________ доц. Лещинський В.О.
								(підпис)
							_______________ доц. Лещинська І.О.
								(підпис)
							_______________ ст. викл. Сокорчук І.П.
								(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет  комп’ютерних наук               Кафедра програмної інженерії                  _
Спеціальність 121 – Інженерія програмного забезпечення                                         _
Курс          3           Семестр                                          6                                                  _
Навчальна дисципліна Архітектура програмного забезпечення                                _

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

.                                                 Шерстюка Андрія Руслановича                                             .
1. Тема проекту: Програмна система для контролю тренувань гірськолижників.                                                                                                 
2. Термін узгодження завдання курсової роботи « 18 »     березня    . 2024 р.
3. Термін здачі студентом закінченої роботи «15»    червня   . 2024 р.
4. Вихідні дані до проекту: завдання щодо розробки унікальної програмної системи з подальшою можливістю монетизації, яка має бути масштабованою, орієнтованою на масового користувача, підтримувати інтернаціоналізацію та локалізацію, із забезпеченням захисту персональних даних та відповідати сучасним стандартам щодо захисту даних. Програмна система повинна включати такі компоненти: серверна частина, клієнтська частина, мобільний програмний застосунок.                                                                                                    
5. Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структуру бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки.                                                             
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма станів, UML діаграма взаємодії, UML діаграма діяльності, програмні копії інтерфейсу програмної системи.                                                                            .                                    


КАЛЕНДАРНИЙ ПЛАН

№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація
програмного проекту	26.03.2024	Виконано
2	Проектування програмного
проекту	05.04.2024	Виконано
3	Кодування програмного проекту	09.06.2024	Виконано
4	Оформлення пояснювальної записки	12.06.2024	Виконано
5	Захист курсової роботи	15.06.2024	Виконано

Дата видачі завдання «	  20   »	березня	 2024 р.

		Керівник 				 	          	      доц. Лещинська І.О.
								(підпис)
		
Завдання прийняв до виконання
ст. гр. ПЗПІ-21-10					      Шерстюк А.Р.
					     (підпис)




РЕФЕРАТ


Пояснювальна записка: 53 сторінки, 6 додатків, 7 рисунків, 3 таблиці, 6 переліків посилання.
ГІРСЬКОЛИЖНИК, ПОДІЯ, ТРЕНЕРИ, ТРЕНУВАННЯ, КОМПАНІЯ, ОСОБИСТИЙ БЛОГ, НАЙКРАЩІ ТРЕНЕРИ, ЛИЖІ, СНОУБОРДІНГ.
Об’єктом розробки є проблема щодо якості контролю тренування та здоров’я гірськолижників а також розвиток системи тренерів. Контроль тренувань гірськолижників включає в себе спостереження за здоров’ям під час тренування та розрахунком критеріїв результату після, запис до тренера та проводження для вдосконалення техніки та результатів, зберігання результатів у список історії тренувань. Всі перелічені процеси мають бути автоматизовані, для полегшення роботи системи контролю тренувань.
Метою роботи є створення програмної системи для контролю тренувань гірськолижників, яка дозволяє спостерігати за здоров’ям, слідкувати за прогресом у тренуваннях, можливість ділитись особистим досвідом через блог, займатися з  тренером для вдосконалення результатів, мати історію результатів, реєструватися компанії, створювати події між користувачами та мати особистих тренерів компанії.
В якості методів розробки було обрано: для серверної частини було обрано мову програмування NodeJS [3] та фреймворк Express яка основана на JavaScript, для зберігання даних користувачів обрано реляційну модель бази даних SQL Server[2, 6], для розробки клієнтської частини обрано мову програмування JavaScript [4] та її бібліотеку React.
В результаті виконання курсової роботи було спроектовано та розроблено програмну систему для контролю тренувань гірськолижників, яка включає в себе серверну та клієнтську частини. Також були використані різні патерни програмування [5].





ЗМІСТ


ВСТУП…………………………………………………………………………………..6
1	Загальні відомості щодо програмної системи……………………..........................7
1.1.	Специфікація програмного забезпечення……………………………………...7
1.2.	Архітектура програмного забезпечення……………………………………….7
2	Розробка серверної частини програмної системи…………………………………9
2.1.	Проектування серверної частини………………………………………………9
2.2.	Опис бази даних та сховища даних…………………………………………...12
2.3.	Архітектура серверної частини………………………………………………..12
2.4.	Опис специфікації Rest API…………………………………………………...13
2.5.	Кодування серверної частини…………………………………………………13
2.6.	Опис дотриманих вимог щодо захисту даних та безпеки даних в системі...14
3	Розробка клієнтської частини програмної системи……………………………...15
3.1.	Архітектура клієнтської частини………………………………………..........15
3.2.	Кодування клієнтської частини……………………………………….………17
Висновки……………………………………………………………………………….18
Перелік джерел посилання…………………………………………………………....19
Додаток А Специфікація програмного забезпечення……………..………………...20
Додаток Б ER-діаграма сутностей бази даних………………………………………36
Додаток В UML діаграма діяльності…………..……………………………………..37
Додаток Г специфікації Rest API ………………..…………………………………...38
Додаток Д програмний код серверної частини ………………..…………………....42
Додаток Ж програмний код клієнтської частини………..………………………….45


ВСТУП


На сьогоднішній день ми маємо декілька проблем щодо контролю тренувань гірськолижників. Серед проблем можна виділити неточність даних під час тренування як здоров’я так і самого тренування, слідкування за особистим прогресом, можливість ведення блогу у даній системі та пошук тренера. Отже, пошук вирішення даних проблем і став причиною до створення програмної системи для контролю тренувань гірськолижників.
Наша програмна система є необхідною, оскільки наразі не існує комплексного рішення для всіх зазначених проблем користувачів.
Дана програмна система орієнтована на сферу контролю тренувань гірськолижників, а також на управління спортивними заходами, контроль за фізичною підготовкою, моніторинг стану здоров'я та онлайн навчання і тренувань.
	Отже, метою курсової роботи є створення програмної система для контролю тренувань гірськолижників, яка складається з серверної та клієнтської частин, та вирішує проблеми неточності даних під час тренування як здоров’я так і самого тренування, слідкування за особистим прогресом, можливість ведення блогу у даній системі та пошук тренера.


1 ЗАГАЛЬНІ ВІДОМОСТІ ЩОДО ПРОГРАМНОЇ СИСТЕМИ
	1.1 Специфікація програмного забезпечення


	Для розробки програмного забезпечення потрібен спеціальний документ – специфікація ПЗ, що містить опис предметної області, загальні та програмні вимоги до системи. Специфікацію програмного забезпечення представлено в додатку А.


	1.2 Архітектура програмної системи

	
	Система має багаторівневу архітектуру, також відома як багатошарова архітектура, вона є структурованим підходом до розробки програмного забезпечення, який розділяє додаток на різні логічні рівні [1]. Ця архітектура дозволяє чітко розділити відповідальність між різними частинами системи, забезпечуючи при цьому масштабованість та безпеку. Кожен рівень виконує певні функції та взаємодіє з іншими рівнями через чітко визначені інтерфейси. Це сприяє модульності, зручності супроводу та масштабованості програми.
	В нашій архітектурі ми маємо наступні рівні:
а)	серверний рівень;
1)	сервер – обробляє бізнес-логіку, виконує обчислення, перевіряє права доступу, оброблює дані користувачів; 
б)	клієнтський рівень;
1)	веб-клієнт – браузерний застосунок, який взаємодіє з користувачем та відправляє запити до серверу;;
в)	рівень даних;
1)	база даних – зберігає дані, забезпечує їх цілісність та надає до них доступ;


	Відобразимо нашу архітектуру на діаграмі розгортання (див. рис. 1.1).

 

Рисунок 1.1 – Діаграма розгортання програмної системи

	Таким чином, була побудована діаграма розгортання, котра демонструє нам загальну архітектуру нашої програмної системи, та те як компоненти взаємодіють між собою у системі.


2 РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
	2.1 Проектування серверної частини


Головним актором системи є «Гірськолижник», він являє собою головного користувача системи, саме для нього і розробляється цей продукт. Він має можливості реєстрації та подальшого входу до системи, може вести особистий блог, записуватися на різні події та знайти собі тренера для подальшого розвитку у вибраному виду спорту. Також він може поділитися своїми враженнями про тренера залишивши відгук на його сторінці, і так само залишити коментар під сервісом. Можливість скаржитися на користувачів, котрі некоректно себе поводять.
Актор «Тренер» представляє собою людину котра має досвід занять в екстремальних видах спорту. Він має такі ж можливості як і атлет, але він ще може додавати клієнтів собі на заняття, але перед цим йому треба перевірити профіль клієнта щоб визначити його рівень підготовки.
Актор «Адміністратор» є адміністратором системи. Він має змогу переглядати заблокованих користувачів, блокувати та розблоковувати їх.         Переглядати таблицю скарг користувача та робити певні висновки.
Актор «Компанія» представляє собою компанію котра має своїх тренерів та надає свої послуги іншим. Компанія має змогу створювати змагання між користувачами та додавати/видаляти тренерів зі свого списку.
	    Відобразимо даних акторів та відповідні їм доступні функції на UML діаграмі. На рисунку 2.1 наведено UML діаграму для звичайного користувача.
 
	
 

Рисунок 2.1 – UML діаграма прецедентів

	Вище наведена діаграма прецедентів користувачів з відповідними для них функціями. 
	Далі створимо UML діаграму компонентів програмної системи. Вона дозволяє визначити архітектуру системи, що розробляється, встановивши залежності між програмними компонентами. 
	Розроблену діаграму компонентів наведено на рисунку 2.2.

 

Рисунок 2.2 – UML діаграма компонентів

	Отже, ми створили діаграму компонентів, яка надає загальну картину архітектури системи, допомагає розробникам та архітекторам краще зрозуміти її структуру та взаємозв'язки.


	2.2 Опис бази даних


ER-модель є структурною моделлю даних що служить для концептуального моделювання предметних областей. Ця модель використовується на етапі високорівневого проектування баз даних і дозволяє ідентифікувати ключові сутності та визначити взаємозв’язки між ними.
ER-діаграма наведена у додатку Б та містить у собі 9 сутностей.  
ER-модель містить наступні сутності:
-	Користувач: Описує всіх користувачів. За допомогою поля role і                         визначається чи користувач є гірськолижником, тренером, компанією або адміністратором;
-	Подія: Описує змагання або збір, котре у системі	створює                                           адміністратор;
-	Пост: Описує пост користувача, котрий веде особистий блог;
-	Рейтинг тренера: Описує рейтинг тренера, котрого оцінили інші користувачі;
-	Коментарі тренера: Описує відгуки та коментарі тренера, котрі залишають інші користувачі;
-	Коментарі сервісу: Описує відгуки всієї системи, котрі залишають  користувачі;
-	Скарги: Описує скарги користувачів котрі некоректно себе поводять;
-	Історія користувача: Описує історію результатів користувача;
-	Компанія: Описує компанію;
	Усі дані нашої програмної системи є структурованими, тому було обрано саме реляційну модель для зберігання даних.  У додатку Б наведено ER-модель даних.


	2.3 Архітектура серверної частини


Серверна частина має чисту архітектуру (Clean architecture) [1]. За допомогою принципів чистої архітектури, серверна частина має високу стійкість до змін. Вона швидко адаптується до нових вимог та можливостей, зберігаючи при цьому високу якість коду та продуктивність. Крім того, система стає набагато простішою для розуміння та супроводу, що робить її більш доступною для інших розробників.
Принципи чистої архітектури також допомагають уникнути проблем із залежностями та розділити додаток на логічні блоки. Це підвищує зручність додавання нових функцій та зміни вже існуючих. В результаті час розробки скорочується, а додаток стає більш гнучким і масштабованим.


	2.4 Опис специфікації REST API


	Специфікація REST – це архітектурний стиль і підхід для розробки веб-сервісів, котрий спрямований на створення масштабованих та простих у використанні web-API. Опис специфікації REST API наведено в таблиці Г.1.


	2.5 Кодування серверної частини


	На серверній частини реалізовані бізнес логіка та можливості управління нею, математичні методи для обробки даних користувачів,.
	Головна бізнес логіка системи:
-	Розрахунок середнього рейтингу тренера: реалізовано функцію підрахунку середнього рейтингу  тренера. Приклад програмного коду, який виконує цей розрахунок наведено в додатку Д. 
-	Підрахунок коефіцієнта здоров’я та тренування: реалізовано метод підрахунку коефіцієнта за критеріями тренувань та показниками здоров’я гірськолижника за певною формулою. Підраховується спочатку коефіцієнт тренування, після здоров’я і за отриманими даними розраховується основний коефіцієнт. Програмний код наведено в додатку Д.


	2.6 Опис дотриманих вимог щодо захисту даних та безпеки в системі


	Відповідно до вимог безпеки в програмній системі застосовуються такі методи захисту даних:
-	Хешування паролів: паролі користувачів зберігаються в базі даних у захешованому вигляді, щоб запобігти доступу до них сторонніх осіб [4].
-	JWT токен: при авторизації користувача створюється JWT токен, який діє протягом 3 годин. Цей токен використовується сервером для перевірки авторизації користувача та надання доступу до функціоналу системи.


3 РОЗРОБКА КЛІЄНТСЬКОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
	3.1 Архітектура клієнтської частини


	Клієнтська частина має Component-Based Architecture (тобто архітектура, заснована на компонентах). Ця архітектура дозволяє розділити клієнтський додаток на незалежні модулі та компоненти, що робить код більш керованим та підтримуваним.

	Спроектуємо та створимо UML діаграму компонентів клієнтської частини.
	Діаграма компонентів - це структурна схема єдиної мови моделювання, яка визначає характеристики фізичного представлення системи. Діаграми компонентів дають повне уявлення про архітектуру системи, допомагаючи розробникам та архітекторам краще зрозуміти її структуру та взаємозв'язки. На рисунку 3.2 показана схема компонентів системи UML.

 

Рисунок 3.2 – UML діаграма компонентів для клієнтської частини програмної системи
	
	Отже, ми розробили діаграму компонентів, яка показує архітектуру нашої системи з точки зору взаємодії її компонентів.
	Далі розробимо UML діаграму станів системи.
Діаграма станів призначена для візуалізації та аналізу різних станів об'єкта чи системи та їх переходів. Вона дозволяє моделювати поведінку системи в залежності від її поточного стану та подій. Загалом, вони допомагають розробникам краще розуміти та моделювати динамічну поведінку систем. Діаграма станів зображена на рисунку 3.3.

 

Рисунок 3.3 - UML діаграма станів 
Побудуємо діаграму діяльності системи.
Діаграма діяльності ілюструє, як координується діяльність для надання послуги, що може відбуватися на різних рівнях абстракції. Вона також показує, як події в одному випадку використання співвідносяться одна з одною, зокрема у ситуаціях, де дії можуть збігатися і потребують узгодження. Ця діаграма також підходить для моделювання того, як набір випадків використання координується для представлення бізнес-процесів. Дана діаграма зображена у додатку В.


	3.2 Кодування клієнтської частини


	Клієнтська частина надає графічний інтерфейс для відображення реалізованої бізнес логіки:
-	Підрахунок рейтингу тренера. Сторінка профілю тренера відображає підрахований рейтинг за допомогою зірочок. Програмний код сторінки Client для відображення рейтингу можна побачити у додатку Ж.
-	Розрахунок коефіцієнта за даними здоров’я та тренування гірськолижника. Блок історії тренувань користувача відображає коефіцієнт котрий був розрахований за певною формулою. Програмний код блоку ResultDetails для відображення коефіцієнту наведено в додатку Ж.


ВИСНОВКИ


	В результаті виконання курсової роботи була спроектована та розроблена програмна система для контролю тренувань гірськолижників, яка складається з серверної та клієнтської частин. Ця система є комплексним рішенням проблем в роботі системи контролю тренувань гірськолижників, а саме: можливість слідкувати за прогресом завдяки історії результатів та коефіцієнтам, можливість ведення блогу у даній системі та пошук онлайн тренера.
	У програмній системі були розроблені усі вимоги щодо безпеки та захисту даних а також інтернаціоналізація. Також реалізована можливість адміністрування а саме слідкування за  користувачами та їхньою поведінкою у системі. Було впроваджено складну бізнес логіку, яка застосовує математичні методи, для обробки даних користувачів. Також була дотримана чистота коду.
	Увесь запланований функціонал було реалізовано в повному обсязі.
	Розроблена програмна система може застосовуватись у сферах контролю тренувань гірськолижників, а також на управління спортивними заходами, контроль за фізичною підготовкою, моніторинг стану здоров'я та онлайн навчання і тренувань.
	
	
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1.	Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides, Design Patterns. Elements of Reusable Object-oriented Software. Addsion Wesley Longman, Print. India East. Press, 1999. – 420 с.
2.	Murach's SQL Server 2019 for Developers, 2020. – 308 с.
3.	Документація по JavaScript. URL: https://javascript.info/ (дата звернення: 06.05.2024).
4.	Документація по NodeJS. URL: https://nodejs.org/en/learn/getting-started/introduction-to-nodejs (дата звернення: 09.04.2024).
5.	Refactoring Guru. URL: https://refactoring.guru/ (дата звернення: 13.04.2024).
6.	Documentation MSSQL SERVER URL: https://learn.microsoft.com/en-us/sql/sql-server/ (дата звернення: 18.05.2024).


ДОДАТОК А
Специфікація програмного забезпечення


1 БІЗНЕС ВИМОГИ
1.1	Передумови


У світі спорту гірськолижники відіграють важливу роль у просуванні гранич. З їхнім виступом пов'язані не лише спортивні досягнення, але і питання	безпеки	та	здоров'я.	Гірськолижники,	незалежно	від	рівня майстерності, постійно піддаються певним ризикам у зв'язку зі специфікою цього виду спорту. Спортсмени зазнають впливу низки чинників, таких як погодні умови, стан гірськолижного маршруту, фізична підготовка та інші.
На сьогоднішній день застосування програмних рішень для контролю тренувань гірськолижників стає дедалі більш актуальним. Завдяки цим технологіям можливо виявити та зменшити ризики, пов'язані з тренуваннями і змаганнями. Надійна система контролю може надати гірськолижникам та їхнім тренерам важливу інформацію щодо фізичного стану.
Відтак, розробка програмної системи контролю тренувань гірськолижників виходить за межі простого застосування технологій. Це ставить перед собою завдання забезпечити безпеку, ефективність та максимальний комфорт для спортсменів у їхній професійній діяльності.


1.2	Можливості для бізнесу


Існуючі продукти в цій галузі включають інші сервіси для контролю тренувань гірськолижників SkiA Sweetspot Trainer та Carv.
SkiA Sweetspot Trainer це система яка допомагає покращити техніку катання та розвинути почуття рівноваги. Вона легка у використанні та не вимагає складного налаштування, підходить для гірськолижників усіхрівнів підготовки. З мінусів даної системи можу виділити що вона не надає аналітику про продуктивність або параметри катання та може бути менш корисним для досвідчених гірськолижників, яким потрібен глибший аналіз та зворотний зв'язок.
Carv, дана система надає докладну аналітику з техніки катання, силових параметрів та рівноваги, має зручний мобільний додаток для відстеження прогресу та отримання рекомендацій. Ще один плюс даної системи це розумні вставки, які легко встановлюються у черевики. Дана система може бути дорогим у придбанні та потребує сумісності з мобільним пристроєм для повноцінної роботи що є мінусам.
Наша система розв'язує актуальну проблему забезпечення безпеки та контролю за фізичним станом гірськолижників у різних умовах для тренувань, матиме ціну котра доступна для більшості користувачів.
Монетизація буде йти від людей котрі займаються гірськолижним видом спорту, відсоток від тренерів та компаній котрі проводять змагання. Ще одним варіантом буде реклама котра буде відображатися користувачу. 


1.3	Цілі бізнесу та критерії успіху


Бізнес-цілі для системи контролю тренувань гірськолижників можуть включати такі кількісні та вимірні показники:
BO-1: Підвищення лояльності клієнтів. Наприклад, мета збільшити кількість постійних клієнтів на 20% у наступному році.
BO-2: Знизити витрати на обслуговування системи на 20% за рік у порівнянні з попереднім роком.
BO-3: Підвищити кількість нових клієнтів 20 тисяч у перший місяць.
SC-1: Розширити географію присутності. Наступного року мати клієнтів з найбільших міст всесвіту де мільйонне населення.
SC-2: Збільшити кількість нових партнерів за перший рік.
SC-3: Збільшення прибутку на 25% за рік порівнюючи з попереднім роком. 


1.4	Потреби клієнта або ринку


На сьогоднішній день багато людей зацікавлені у занятті гірськолижним видом спорту, і для того
Користуючись нашим сервісом клієнти отримують комфортний, простий у використанні та зручний інтерфейс. Дає можливість обирати тренера для вдосконалення своїх навичок та покращення результатів. Постійну технічну підтримку, яка буде надавати цілодобову допомогу телефоном або електронною поштою. Можливість ведення особистого блогу для публікації своїх успіхів та досягнень. І саме головне те що система буде слідкувати за характеристиками здоров’я та результатами тренування.
Тренери можуть розробляти індивідуальні програми для покращення результатів своїх клієнтів. Також вони повинні бути зареєстровані у компанії котра і надає їх послуги.
Компанії зможуть створювати змагання для користувачів даного сервісу, а також вести блог для того щоб ділитися новинами для залучення нових клієнтів.


1.5	Бізнес-ризики


Далі розписано ризики для нашого сервісу.
1)	Конкуренція на ринку:
Ризик: Наявність інших сервісів може ускладнити залучення клієнтів. Серйозність: висока.
 
Спосіб зниження ризику: Необхідно дослідити конкурентів і пропонувати більш вигідний досвід користування сайтом. Треба розробити кращу цінову політику, ніж в конкурентів. Спостереження за конкурентами, постійне оновлення та розвиток системи, розробка унікальних функцій і послуг для користувачів
2)	Проблеми з даними та конфіденційність:
Ризик: Втрата або незаконний доступ до особистих даних користувачів може призвести до порушення конфіденційності та втрати довіри спортсменів.
Серйозність: висока
Спосіб зниження ризику: Забезпечити надійний захист даних шляхом використання сучасних технологій шифрування та встановлення строгих політик конфіденційності.
3)	Проблеми із сумісністю та інтеграцією:
Ризик: Несумісність інформаційних систем з іншими пристроями та додатками може обмежити функціональність системи та знизити її ефективність.
Серйозність: середня
Спосіб зниження ризику: Необхідно передбачити можливість інтеграції з іншими технологіями та стандартами, а також встановити механізми тестування та відладки.
5) Невідповідність вимогам законодавства:
Ризик: Система може не відповідати вимогам законодавства у сфері захисту персональних даних, безпеки, здоров'я та безпеки.
Серйозність: висока
Спосіб зниження ризику: Необхідно провести оцінку відповідності системи вимогам законодавства та внести необхідні зміни. Цей пункт відбиває важливий ризик, що може вплинути успіх системи. Система
 
повинна відповідати всім застосовним законам та нормативним актам, щоб гарантувати безпеку та конфіденційність користувачів.
 

2 БАЧЕННЯ РІШЕННЯ
2.1	Окреслення концепції


Система призначена для користувачів котрі займаються гірськолижним видом спорту, та хочуть забезпечити собі безпеку під час заняття та вдосконалити свої навички. Слідкування за здоров’єм дає змогу не відволікатися на своє здоров’я, бо датчики все будуть робити за вас, а саме вимірювати тиск та температуру тіла. Результати ефективності тренування будуть давати змогу відстежити свої помилки та уникнути їх у майбутньому. Для користувачів є можливість записатися на тренування до тренера, для вдосконалення власних навичок, а тренери можуть набирати собі клієнтів для тренувань. Можливість фільтрації на сторінці тренерів дозволить обрати самих досвідчених тренерів. Кожен користувач зможе поділитися враженнями після занять у своєму блозі або залишити коментар для тренера. Для спортсменів котрі хочуть порівняти свої сили з іншими буде можливість взяти участь у змаганнях котрі створюватимуть компанії.


2.2	Основні особливості


MF-1: Залишити коментар під профілем тренера – ця функція дозволяє користувачам ділитися враженнями від тренувань будь якого тренера.
MF-2: Залишати коментарі під сервісом – ця функція призначена для всіх користувачів, котрі хочуть залишити свій відгук про нашу систему, на основі яких ми будем виправляти всі недоліки котрі ми отримали.
МF-3: Відстеження фізичного стану гірськолижника. Система буде збирати дані про фізичну активність під час заняття певним видом спорту, їхній пульс, тепмературу тіла та кисень у крові. 
МF-4: Відстеження результату тренування. Система буде збирати дані про тренування а саме, швидкість, кут нахилу.
MF-5: Залишати скарги на інших користувачів – ця функція дозволить блокувати підозрілих користувачів, котрі можуть займатись рекламою під коментарями чи нечемно себе вести.
MF-6: Збереження особистих параметрів користувача в особистому кабінеті - особистий кабінет може містити різні поля для збереження особистих параметрів користувача, такі як ім'я, електронна пошта та інші.
MF-7: Відображення рейтингу тренерів - ця функція може допомогти користувачеві відстежувати найкращих тренерів з високими рейтингами.
MF-8: Створення змагань між користувачами – ця функція дозволяю компанії створити змагання між користувачами.
MF-9: Гірськолижник може перегляди історію змінення своїх результатів тренувань.
MF-10: Тренер або гірськолижник може вести особистий блог, де розповідає про свої успіхи або своїх учнів та рекомендації щодо тренувань.


2.3	Припущення і залежності


Зал	№1	—	Продукт	користуватиметься	популярністю	серед гірськолижників через свою унікальність та корисність.
Зал №2 — Продукт зможе виконувати поставленні задачі, тільки при підключенні до мережі
Зал №3 — Для виконання поставлених задач для користувачів, продукту потрібні його дані для зворотнього зв’язку та гарантій безпеки.
Зал №4 — Для роботи з системою повинна бути наявне стабільне енергопостачання.
При №1 — Для роботи з продуктом потрібно мати наступні ОС: Windows 7+, ОС 6+
При №2 — Для відповіді на поставлену задачу користувачем, потрібні потужні сервери та стабільне підключення до інтернету.
При №3 — Швидкість оновлення інформації у додатку залежить від завантаженості серверів.
При №4 — Для роботи з мобільним застосунком користувач має мати певну версію мобільної системи: IOS 16+, Android 13+
 

3 РАМКИ ТА ОБМЕЖЕННЯ
3.1	Обсяг початкового випуску 


Серверна частина:
1.	Взаємодіє з базою даних.
2.	Взаємодіє з web, mobile та IoT частинами, відправляє та приймає дані від них.
3.	Робить обчислення даних отриманих від IoT частини з показниками здоров’я та відправляє на web частину.
4.	Рахує кількість скарг та передає певні попередження на web частину.
5.	Рахує коефіцієнт ефективності тренування отриманих від IoT частини та відправляє на web частину.

Smart device/IoT частина взаємодіє з сервером, відправляє дані щодо фізичного стану користувача та результату тренування.

Web частина для користувачів:
1.	Реєстрація та авторизація користувача в системі.
2.	Перегляд фізичних показників гірськолижників.
3.	Перегляд показників тренувань.
3.      Залишати скарги на користувачів.
5.	Залишати коментарі для тренера.
6.	Залишати коментарі для системи.
7.	Вести особистий блог.
8.	Створювати змагання між користувачами.
9.	Записуватись до тренерів на тренування.
 
Web частина для адміністратора:
1.	Блокувати та розблокувати користувачів.
2.	Переглядати всіх користувачів та видаляти їх акаунти.


Mobile частина:
1.	Авторизація користувачів в системі.
2.	Перегляд показників здоров’я.
3.	Перегляд попередніх результатів тренувань.
4.	Залишати скарги на користувачів.


3.2	Сфера дії наступних випусків


Розвинута система чату зі штучним інтелектом та можливість голосових сигналів буде відкладено на майбутні релізи. Моніторинг стану довкілля: температури, вологості, атмосферного тиску. Спостереження за групою гірськолижників: відстеження розташування та стану кожного спортсмена у групі. Інтеграція з іншими системами: інтеграція із системами екстреної допомоги, системами моніторингу погоди та іншими системами.


3.3	Обмеження та виключення


1)	Мережа спілкування для користувачів: Платформа, яка дозволяє користувачам обмінюватися інформацією, досвідом та порадами.
2)	Відстеження погодних умов та рекомендації щодо безпечних умов для занять спортом: Інтеграція з сервісами прогнозу погоди для надання рекомендацій щодо безпечних умов для занять спортом.
3)	Інтерактивні тренування та відеоуроки від професіоналів гірськолижників: Вона могла б допомогти користувачам покращити свої навички, але в наступній версії планується розвинути цю функцію.
4)	Сповіщення та статистика про середню тривалість життя продукту та користувачів: Функція, яка забезпечує статистичну інформацію про тривалість використання продукту користувачами, але це може вимагати значних зусиль для реалізації.
 

4 БІЗНЕС-КОНТЕКСТ
4.1	Профілі зацікавлених сторін


Таблиця 1.1 - Профілі зацікавлених сторін

Зацікавлена
сторона	Головна
цінність	Ставлення	Головний інтерес	Обмеження
Керівники	Розвиток
компанії	та зростання доходів	Продукт розглядається як	шлях	та спосіб
отримання заробітку	та збільшення
частки	ринку на 20%	Набір        функцій
більш ніж у конкурентів;
запуск системи та виход на ринок швидший;
ефективне управління
ресурсами	та витратами	Максимальний бюджет: 1 млн дол.	США; строки впровадження та	вимоги	до вибору технологій.
Користувачі	Зручний	та легкий інтерфейс,
безпроблемне використання системою	Зацікавлений у
використанні системи	для покращення
своїх
результатів та зниження ризиків травм	Безпека особистого здоров’я,
слідкування за станом здоров’я, попередження про небезпеку	Можливість зв’язку	з тренером лише через пошту
 
Продовження таблиці 1.1


Тренери	Підвищення результатів та здоров'я
клієнтів.	Зацікавлений у
використанні системи	для забезпечення безпеки
спортсменів та відстеження їх результатів	Отримання точних даних	про
фізичний стан та ризики	для оптимізації
тренувальних програм.	Працюють онлайн, та самі домовляються з клієнтами,	не мають	місця для тренувань
Адміністратори	Швидкий доступ доданих;
Забезпечення безперебійної роботи	та підтримки
системи
відстеження.	Цінність
безперебійної роботи
системи та її відповідності вимогам
безпеки	та конфіденційн ості	Система легка у вивчені; легка взаємодія з базою даних	через інтерфейс	Бюджету на перепідготовку немає;
необхідність дотримання регуляторних вимог.
Компанії	Розвиток
компанії	та зростання доходів	Сильно зацікавлений у безпеці	своїх клієнтів.	Розвиток репутації та прибутку	Максимальний бюджет: 0.5 млн дол. США.
 

4.2	Пріоритети проекту


Таблиця 1.2 - Пріоритети проєкту


Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	випуск 1.0 стане доступним до
20.11 ц. р., випуск 1.1 – до		
Функції			функцій із високим пріоритетом мають бути включені до випуску 1.0
Якість			у випуску 1.0 повинні пройти 87- 92% тестів, у
випуску 1.1 – 92 – 97%
Персонал		максимальний розмір команди: розробників та 4 тестувальника	
Ціна			Допустимо перевищити бюджет на 10% без перегляду робіт
 

4.3	Операційне середовище


Середовище, в якому буде використовуватися система, включає користувачів, що мешкають в різних куточках землі з різними часовим поясом. Система повинна коректно працювати при підключенні до мережі Інтернет при великій кількості користувачів.
Програмна система має наступне робоче середовище:

1.	Серверна частина:

a)	Буде	розроблюватися	на	мові	програмування	NodeJS	з використанням фреймворку Express;
b)	У якості СУБД обрано реляційну базу даних MS SQL Server;

2.	Web частина:

Буде розроблена за допомогою HTML5, CSS та JavaScript, з використанням бібліотеки React та препроцесора SCSS;

3.	Mobile застосунок:

Буде розроблений за допомогою мови програмування Kotlin;

4.	IoT або SmartDevice буде взаємодіяти з системою за допомогою бібліотеки Raspberry Pi;


ДОДАТОК Б 	
ER-діаграма сутностей бази даних

 
 
ДОДАТОК В
UML діаграма діяльності
 
 
ДОДАТОК Г
Таблиця для опису специфікації Rest API


Таблиця Г.1 – Опис специфікації Rest API

Контролер	Метод	Маршрут	Опис
User	GET	api/authUser	Повертає дані авторизованого
користувача
		api/userHistory	Повертає історію результатів користувача
	POST	api/addResult	Додавання нового
результату у історію
		api/addReport	Додавання скарги на
користувача
		api/addComentToService	Додавання відгука про
сервіс
		api/addComentToCoach	Додавання відгука про
тренера
	PATCH	api/changeUserData	Зміна особистих даних
	DELETE	api/deleteResult	Видалення результату з
історії
		api/deleteUser	Видалення особистого
акаунту
 
Продовження таблиці Г.1

Admin	GET	api/bannedUsers	Отримання всіх заблокованих користувачів
		api/getReports/:id	Отримання	репортів
користувача	по ідентифікатору
	PATCH	api/addBannedUser/:id	Заблокувати користувача
		api/deleteBannedUser/:id	Розблокувати
користувача
Coach	GET	coach/clients/:id	Отримання всіх клієнтів
тренера по ідентифікатору
		coach/comments/:id	Отримання	відгуків тренера		по
ідентифікатору
		coach/topCoaches	Отримання	кращих
тренерів за рейтингом
	POST	coach/addClient?id	Відправлення		заяви клієнта	на	запис	до
тренера
		coach/addRating?id	Додавання рейтингу до
тренера
	PATCH	coach/acceptClient?id	Підтвердження	заяви
клієнта
		coach/changeRating?id	Зміна рейтингу тренера
	DELETE	coach/deleteClient/:id	Видалення	клієнта	зі
списку тренера
 
Продовження таблиці Г.1

Event	GET	events/allEvents	Отримання всіх подій
		events/event/:id	Отримання однієї події
по ідентифікатору
		events/eventsWithFilters	Отримання	подій	за
фільтрами
	POST	events/addEvent	Додавання нової події
		events/addUserToEvent	Додавання	користувача
до події
	DELETE	events/deleteEvent?id	Видалення події
Post	GET	post/getAllPersonalPosts	Отримання	постів авторизованого
користувача
		post/getAllUserPosts/:id	Отримання	постів
користувача	по ідентифікатору
	POST	post/addPost	Додавання нового посту
	PATCH	post/editPost/:id	Редагування	посту	по
ідентифікатору
	DELETE	post/deletePost/:id	Видалення	посту	по
ідентифікатору
Company	GET	company/getCompanies	Отримання всіх компаній
		company/getAuthCompany	Отримання авторизованої      компанії
		company/getCoaches	Отримання тренерів авторизованої компанії
		company/getCompany/:id	Отримання компанії по
ідентифікатору
	POST	company/registration	Реєстрація компанії

Продовження таблиці Г.1
		company/login	Авторизація компанії
		company/addCoach/:id	Відправка заявки на запис до команди тренерів компанії
	PATCH	company/acceptCoach/:id	Підтвердження	заяви
тренера
	DELETE	company/deleteCoach/:id	Відмова заяви тренера
Auth	POST	api/registration	Реєстрація користувача
		api/login	Перевірка користувача
 unAuth	 GET	unAuth/serviceComments	Отримання відгуків про
сервіс
		unAuth/allUsers?role	Отримання			всіх користувачів	за	роллю
(окрім адміністраторів)
		unAuth/allUsersWithFilters	Отримання користувачів
по фільтрам
		unAuth/user/:id	Отримання	користувача
за ідентифікатором


ДОДАТОК Д
Програмний код серверної частини


Програмний код підрахунку середнього рейтингу тренера:

 
async getTopCoaches(sport_type) {
    try {
      const pool = await sql.connect(dbConfig);
      const betterCoaches = await pool
        .request()
        .query(`SELECT TOP 5 U.id, U.name, U.lastname, U.role, AVG(CR.ratingValue) AS avgRating
              FROM [User] U
              JOIN [Coach_ratings] CR ON U.id = CR.coachId
              WHERE U.role = 'coach' AND U.sport_type = '${sport_type}'
              GROUP BY U.id, U.name, U.lastname, U.role, U.sport_type
              ORDER BY avgRating DESC;
            `);

      return betterCoaches.recordset;
    } catch (error) {
      console.error(error);
      throw error;
    }
  } 
Програмний код функції підрахунку коефіцієнту тренування:

 
async getUserHistory(token){
  try {
    const pool = await sql.connect(dbConfig);
    const userId = await tokenService.getUserIdFromToken(token);
    // get userData
    const userData = await pool.request().query(`SELECT * FROM [User] WHERE id=${userId}`);
    // get user results
    const resultsHistory = await pool.request().query(`SELECT * FROM [Users_history] WHERE userId = ${userId} ORDER BY dateOfTrain DESC`);
    // Add coefficients and phrases to each history object
    return resultsHistory.recordset.map((entry) => {
      const passage_length = entry.result;
      const heartbeatCoefficient = entry.heartbeat * 0.4;
      const oxygenCoefficient = entry.oxygen * 0.3;
      const temperatureCoefficient = entry.temperature * 0.3;
      const weightCoefficient = userData.recordset[0].weight * 0.2;
      const heightCoefficient = userData.recordset[0].height * 0.1;
      const middleSpeedCoefficient = entry.middle_speed * 0.2;
      const tiltAngleCoefficient = entry.tilt_angle * 0.1;

      const healthCoefficient = (heartbeatCoefficient + oxygenCoefficient +
        temperatureCoefficient + weightCoefficient + heightCoefficient).toFixed(2);

      const trainCoefficient = (passage_length /
        (weightCoefficient + heightCoefficient + middleSpeedCoefficient + tiltAngleCoefficient)).toFixed(2);

      // Implement the determineCategory function, which will return a phrase depending on the coefficient
      const healthCategory = determineHealthCategory(healthCoefficient);
      const trainCategory = determineTrainCategory(trainCoefficient);

      return {
        ...entry,
        healthCoefficient,
        trainCoefficient,
        healthCategory,
        trainCategory
      };
    });

    function determineHealthCategory(coefficient) {
      if (coefficient < 50) {
        return 'red';
      } else if (coefficient >= 50 && coefficient < 75) {
        return 'yellow';
      } else {
        return 'lightgreen';
      }
    }

    function determineTrainCategory(coefficient) {
      if (coefficient < 5) {
        return 'red';
      } else if (coefficient >= 5 && coefficient < 10) {
        return 'yellow';
      } else {
        return 'lightgreen';
      }
    }
  } catch (error) {
    console.error(error);
    throw error;
  }
} 


ДОДАТОК Ж
Програмний код клієнтської частини


Програмний код сторінки Client:


import React, { useState, useEffect } from "react";
import { useParams } from "react-router-dom";
import axios from "axios";
import { ToastContainer } from "react-toastify";
import { useTranslation } from "react-i18next";

import Header from "../../components/Header";
import StarsRating from "../../components/StarsRating";
import Posts from "../../components/Posts";
import SendingForm from "./SendingForm";
import CoachComments from "./CoachComments";
import ReportsList from "./ReportsList";
import Footer from "../../components/Footer";
import toastSuccess from "../../utils/toast/toastSuccess";
import toastError from "../../utils/toast/toastError";
import CheckRole from "../../utils/auth/checkRole";
import user from "../../assets/free-icon-user-7630236.png";

import "./index.scss";
import "react-toastify/dist/ReactToastify.css";

const Client = () => {
  const { t } = useTranslation();
  const currentRole = CheckRole();
  const [userData, setUserData] = useState({});
  const [rating, setRating] = useState(0);
  const [isReportFormOpen, setIsReportFormOpen] = useState(false);
  const [isFeedbackFormOpen, setIsFeedbackFormOpen] = useState(false);
  const [reportsView, setReportsView] = useState(false);
  const { userId } = useParams();
  const token = localStorage.getItem("token");

  const changeReportFormView = () => {
    setIsReportFormOpen((prev) => !prev);
  };

  const changeFeedbackFormView = () => {
    setIsFeedbackFormOpen((prev) => !prev);
  };

  const changeReportsView = () => {
    setReportsView((prev) => !prev);
  };

  useEffect(() => {
    axios.get(`http://localhost:5000/unAuth/user/${userId}`)
      .then((response) => {
        setUserData(response.data);
      });
  }, [rating]);

  const sendApplication = (coachId) => {
    axios.post(`http://localhost:5000/coach/addClient/${coachId}`, {}, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
      .then((response) => {
        toastSuccess(response.data);
      })
      .catch((err) => {
        if (err.request.status === 401) {
          toastError("You need to log in");
          return;
        }
        toastError("???");
      });
  };

  const ratingChanged = (newRating) => {
    setRating(newRating);
    axios.post("http://localhost:5000/coach/addRating", {
      userId,
      newRating,
    }, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
      .then((response) => {
        toastSuccess(response.data);
      })
      .catch((err) => {
        if (err.request.status === 401) {
          toastError("You need to log in");
          return;
        }
        if (err.request.status === 400) {
          toastError("You have already rated");
          return;
        }
        toastError("???");
      });
  };

  const sendCoachFeedback = (coachId) => (value) => {
    axios.post("http://localhost:5000/api/addCommentToCoach", { value: value.text, coachId }, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
      .then((response) => {
        changeFeedbackFormView();
        toastSuccess(response.data);
      })
      .catch((err) => {
        if (err.request.status === 401) {
          toastError("You need to log in");
          return;
        }
        if (err.request.status === 400) {
          toastError("You have already left a comment");
          return;
        }

        toastError("???");
      });
  };

  const sendReport = (recipientId) => (value) => {
    axios.post("http://localhost:5000/api/addReport", { value: value.text, recipientId }, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
      .then((response) => {
        changeReportFormView();
        toastSuccess(response.data);
      })
      .catch((err) => {
        if (err.request.status === 401) {
          toastError("You need to log in");
          return;
        }
        if (err.request.status === 400) {
          toastError("You have already filed a complaint against the user");
          return;
        }

        toastError("???");
      });
  };

  const banUser = (id) => {
    axios.patch(`http://localhost:5000/api/addBannedUser/${id}`, {}, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
      .then((response) => {
        toastSuccess(response.data);
      })
      .catch(() => {
        toastError("???");
      });
  };

  const unbanUser = (id) => {
    axios.patch(`http://localhost:5000/api/deleteBannedUser/${id}`, {}, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
      .then((response) => {
        toastSuccess(response.data);
      })
      .catch(() => {
        toastError("???");
      });
  };

  return (
    <>
      <ToastContainer style={{ width: "330px" }} />
      <Header />
      <div className="user-container">
        <img src={user} className="user-container-photo" alt="user" />

        <div className="user-info">
          <span>
            {t("clientPage.name")}
            {userData.name}
          </span>
          <span>
            {t("clientPage.lastname")}
            {userData.lastname}
          </span>
          <span>
            {t("clientPage.role")}
            {userData.role}
          </span>
          {userData.role === "coach" ? (
            <>
              <span>
                {t("clientPage.price")}
                {userData.price}
                $
              </span>
              <span>
                {t("clientPage.rating")}
                <StarsRating
                  ratingChanged={ratingChanged}
                  initialValue={userData.rating}
                />
              </span>
            </>
          ) : ""}
          <span>
            {t("clientPage.age")}
            {userData.age}
          </span>
          <span>
            {t("clientPage.country")}
            {userData.country}
          </span>
          <span>
            {t("clientPage.city")}
            {userData.city}
          </span>
          <span>
            {t("clientPage.specialized")}
            {userData.sport_type}
          </span>
          <span>
            {t("clientPage.experience")}
            {userData.experience}
            {" "}
            years
          </span>
          <span>
            {t("clientPage.contact")}
            {" "}
            {userData.mail}
          </span>
          <div className="user-info-btns">
            {userData.role === "coach" ? (
              <>
                <button
                  type="button"
                  onClick={() => sendApplication(userId)}
                >
                  {t("clientPage.lessonApplicationBtn")}
                </button>
                <button type="button" onClick={changeFeedbackFormView}>{t("clientPage.feedbackParagraph")}</button>
              </>
            ) : ""}
            <button type="button" onClick={changeReportFormView}>{t("clientPage.reportParagraph")}</button>
            {/* eslint-disable-next-line no-nested-ternary */}
            {currentRole === "admin" && (
              <>
                {userData.is_banned
                  ? <button type="button" onClick={() => unbanUser(userId)}>Unban</button>
                  : <button type="button" onClick={() => banUser(userId)}>Ban</button>}
                <button type="button" onClick={changeReportsView}>{t("clientPage.reportList.button")}</button>
              </>
            )}
          </div>
        </div>
      </div>
      {reportsView && <ReportsList userId={userId} closeList={changeReportsView} />}
      <SendingForm
        onSubmit={sendReport(userData.id)}
        closeForm={changeReportFormView}
        blockName={t("clientPage.reportParagraph")}
        isFormOpen={isReportFormOpen}
      />
      <SendingForm
        onSubmit={sendCoachFeedback(userData.id)}
        closeForm={changeFeedbackFormView}
        blockName={t("clientPage.feedbackParagraph")}
        isFormOpen={isFeedbackFormOpen}
      />
      {userData.role === "coach" ? <CoachComments coachId={userId} /> : ""}
      <Posts user userId={userId} />
      <Footer />
    </>
  );
};

export default Client; 


Наведемо програмний код сторінки ResultDetails:
 
import React, { useState, useEffect } from "react";
import axios from "axios";
import PropTypes from "prop-types";
import { useTranslation } from "react-i18next";

import formatDate from "../../../../utils/formatDate";

import "./index.scss";

const ResultDetails = ({ id, onClose }) => {
  const { t } = useTranslation();
  const token = localStorage.getItem("token");
  const [details, setDetails] = useState({});
  const [isCelsius, setIsCelsius] = useState(true);

  useEffect(() => {
    axios.get(`http://localhost:5000/api/userHistory/result/${id}`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
      .then((response) => {
        setDetails(response.data);
      })
      .catch((err) => {
        console.log(err);
      });
  }, [id]);

  const convertCelsiusToFahrenheit = (celsius) => {
    // eslint-disable-next-line no-restricted-globals
    if (typeof celsius !== "number" || isNaN(celsius)) {
      return "Invalid Temperature";
    }
    // eslint-disable-next-line no-mixed-operators
    const fahrenheit = (celsius * 9 / 5) + 32;
    return `${fahrenheit.toFixed(2)} °F`;
  };

  const handleToggleTemperatureUnit = () => {
    setIsCelsius((prev) => !prev);
  };

  if (!details || Object.keys(details).length === 0) {
    return <p>Loading...</p>;
  }

  return (
    <div className="result">
      <button type="button" onClick={onClose} className="result-close">
        {t("accountPage.history.closeDetails")}
      </button>
      <h2>{t("accountPage.history.resultDetails")}</h2>
      <div>
        {t("accountPage.history.rules")}
      </div>
      <p>
        {t("accountPage.history.result")}
        {" "}
        {details.result}
        {" "}
        {t("accountPage.history.meters")}
      </p>
      <p>
        Health coefficient
        {": "}
        {Math.round(details.healthCoefficient)}
      </p>
      <p>
        Train coefficient
        {": "}
        {details.trainCoefficient}
      </p>
      <p>
        {t("accountPage.history.heartbeat")}
        {" "}
        {details.heartbeat}
        {" "}
        {t("accountPage.history.heartbeatPerMinute")}
      </p>
      <p>
        {t("accountPage.history.oxygen")}
        {" "}
        {details.oxygen}
        {" "}
        %
      </p>
      <p>
        Middle speed:
        {" "}
        {details.middle_speed}
        {" "}
        km/h
      </p>
      <p>
        Tilt angle:
        {" "}
        {details.tilt_angle}
        {" "}
        degrees
      </p>
      <div className="result-temperature">
        <p>
          {t("accountPage.history.temperature")}
          {" "}
          {isCelsius ? `${details.temperature} ℃` : convertCelsiusToFahrenheit(details.temperature)}
        </p>
        <button type="button" onClick={handleToggleTemperatureUnit}>
          {isCelsius ? t("accountPage.history.fahrenheit") : t("accountPage.history.celsius")}
        </button>
      </div>
      <p>
        {t("accountPage.history.date")}
        {": "}
        {formatDate(details.dateOfTrain)}
      </p>
    </div>
  );
};

ResultDetails.propTypes = {
  id: PropTypes.number,
  onClose: PropTypes.func,
};

export default ResultDetails;
 

